


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>enaml.core.base_component &mdash; enaml 0.2alpha documentation</title>
    
    <link rel="stylesheet" href="../../../_static/enthought_doc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/et.ico"/>
    <link rel="top" title="enaml 0.2alpha documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../enaml-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">enaml 0.2alpha documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li>
  
    <li><a href="#">enaml.core.base_component</a></li>
  

      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/e-logo-rev.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for enaml.core.base_component</h1><div class="highlight"><pre>
<span class="c">#------------------------------------------------------------------------------</span>
<span class="c">#  Copyright (c) 2011, Enthought, Inc.</span>
<span class="c">#  All rights reserved.</span>
<span class="c">#------------------------------------------------------------------------------</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="kn">from</span> <span class="nn">traits.api</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Bool</span><span class="p">,</span> <span class="n">HasStrictTraits</span><span class="p">,</span> <span class="n">Instance</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Property</span><span class="p">,</span> <span class="n">Str</span><span class="p">,</span> <span class="n">WeakRef</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> 
    <span class="n">Disallow</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.expressions</span> <span class="kn">import</span> <span class="n">AbstractExpression</span>
<span class="kn">from</span> <span class="nn">.toolkit</span> <span class="kn">import</span> <span class="n">Toolkit</span>
<span class="kn">from</span> <span class="nn">.trait_types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">EnamlEvent</span><span class="p">,</span> <span class="n">LazyProperty</span><span class="p">,</span> <span class="n">UserAttribute</span><span class="p">,</span> <span class="n">UserEvent</span><span class="p">,</span> <span class="n">ExpressionTrait</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="BaseComponent"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent">[docs]</a><span class="k">class</span> <span class="nc">BaseComponent</span><span class="p">(</span><span class="n">HasStrictTraits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The most base class of the Enaml component hierarchy.</span>

<span class="sd">    All declarative Enaml classes should inherit from this class. This </span>
<span class="sd">    class is not meant to be instantiated directly.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#: A readonly property which returns the current instance of</span>
    <span class="c">#: the component. This allows declarative Enaml components to</span>
    <span class="c">#: access self according to the standard attribute scoping rules.</span>
    <span class="bp">self</span> <span class="o">=</span> <span class="n">Property</span>

    <span class="c">#: The parent component of this component. It is stored as a weakref</span>
    <span class="c">#: to mitigate issues with reference cycles. A top-level component&#39;s</span>
    <span class="c">#: parent is None.</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">WeakRef</span><span class="p">(</span><span class="s">&#39;BaseComponent&#39;</span><span class="p">)</span>

    <span class="c">#: The list of children for this component. This is a read-only</span>
    <span class="c">#: lazy property that is computed based on the static list of</span>
    <span class="c">#: _subcomponents and the items they return by calling their</span>
    <span class="c">#: &#39;get_actual&#39; method. This list should not be manipulated by</span>
    <span class="c">#: user code.</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">LazyProperty</span><span class="p">(</span>
        <span class="n">List</span><span class="p">(</span><span class="n">Instance</span><span class="p">(</span><span class="s">&#39;BaseComponent&#39;</span><span class="p">)),</span> 
        <span class="n">depends_on</span><span class="o">=</span><span class="s">&#39;_subcomponents:_actual_updated&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c">#: Whether the component has been initialized or not. This will be </span>
    <span class="c">#: set to True after all of the setup() steps defined here are </span>
    <span class="c">#: completed. It should not be changed afterwards. This can be used </span>
    <span class="c">#: to trigger certain actions that need to occur after the component </span>
    <span class="c">#: has been set up.</span>
    <span class="n">initialized</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

    <span class="c">#: An optional name to give to this component to assist in finding</span>
    <span class="c">#: it in the tree. See the &#39;find_by_name&#39; method.</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Str</span>

    <span class="c">#: A reference to the toolkit that was used to create this object.</span>
    <span class="n">toolkit</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">Toolkit</span><span class="p">)</span>

    <span class="c">#: The private dictionary of expression objects that are bound to </span>
    <span class="c">#: attributes on this component. It should not be manipulated by</span>
    <span class="c">#: user code. Rather, expressions should be bound by calling the </span>
    <span class="c">#: &#39;bind_expression&#39; method.</span>
    <span class="n">_expressions</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">(</span><span class="n">Str</span><span class="p">,</span> <span class="n">List</span><span class="p">(</span><span class="n">Instance</span><span class="p">(</span><span class="n">AbstractExpression</span><span class="p">)))</span>

    <span class="c">#: The private list of virtual base classes that were used to </span>
    <span class="c">#: instantiate this component from Enaml source code. The </span>
    <span class="c">#: EnamlFactory class of the Enaml runtime will directly append</span>
    <span class="c">#: to this list as necessary.</span>
    <span class="n">_bases</span> <span class="o">=</span> <span class="n">List</span>

    <span class="c">#: The private internal list of subcomponents for this component. </span>
    <span class="c">#: This list should not be manipulated by the user, and should not</span>
    <span class="c">#: be changed after initialization. It can, however, be redefined</span>
    <span class="c">#: by subclasses to limit the type or number of subcomponents.</span>
    <span class="n">_subcomponents</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">Instance</span><span class="p">(</span><span class="s">&#39;BaseComponent&#39;</span><span class="p">))</span>

    <span class="c">#: A private event that should be emitted by a component when the </span>
    <span class="c">#: results of calling get_actual() will result in new values. </span>
    <span class="c">#: This event is listened to by the parent of subcomponents in order </span>
    <span class="c">#: to know when to rebuild its list of children. User code will not </span>
    <span class="c">#: typically interact with this event.</span>
    <span class="n">_actual_updated</span> <span class="o">=</span> <span class="n">EnamlEvent</span>

    <span class="c">#: The HasTraits class defines a class attribute &#39;set&#39; which is</span>
    <span class="c">#: a deprecated alias for the &#39;trait_set&#39; method. The problem</span>
    <span class="c">#: is that having that as an attribute interferes with the </span>
    <span class="c">#: ability of Enaml expressions to resolve the builtin &#39;set&#39;,</span>
    <span class="c">#: since the dynamic attribute scoping takes precedence over</span>
    <span class="c">#: builtins. This resets those ill-effects.</span>
    <span class="nb">set</span> <span class="o">=</span> <span class="n">Disallow</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Special Methods</span>
    <span class="c">#--------------------------------------------------------------------------</span>
<div class="viewcode-block" id="BaseComponent.__repr__"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; An overridden repr which returns the repr of the factory </span>
<span class="sd">        from which this component is derived, provided that it is not </span>
<span class="sd">        simply a root constructor. Otherwise, it defaults to the super</span>
<span class="sd">        class&#39; repr implementation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If there are any bases, the last one in the list will always </span>
        <span class="c"># be a constructor. We want to ignore that one and focus on the</span>
        <span class="c"># repr of the virtual base class from which the component was </span>
        <span class="c"># derived in the Enaml source code.</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bases</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BaseComponent</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Property Getters</span>
    <span class="c">#--------------------------------------------------------------------------</span></div>
    <span class="k">def</span> <span class="nf">_get_self</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The property getter for the &#39;self&#39; attribute.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
        
    <span class="k">def</span> <span class="nf">_get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The lazy property getter for the &#39;children&#39; attribute.</span>

<span class="sd">        This property getter returns the flattened list of components</span>
<span class="sd">        returned by calling &#39;get_actual()&#39; on each subcomponent.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">get_actual</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">],</span> <span class="p">[])</span>
    
    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Component Manipulation</span>
    <span class="c">#--------------------------------------------------------------------------</span>
<div class="viewcode-block" id="BaseComponent.get_actual"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.get_actual">[docs]</a>    <span class="k">def</span> <span class="nf">get_actual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the list of BaseComponent instances which should be</span>
<span class="sd">        included as proper children of our parent. By default this </span>
<span class="sd">        simply returns [self]. This method should be reimplemented by </span>
<span class="sd">        subclasses which need to contribute different components to their</span>
<span class="sd">        parent&#39;s children.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        </div>
<div class="viewcode-block" id="BaseComponent.add_subcomponent"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.add_subcomponent">[docs]</a>    <span class="k">def</span> <span class="nf">add_subcomponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Adds the given component as a subcomponent of this object.</span>
<span class="sd">        By default, the subcomponent is added to an internal list of </span>
<span class="sd">        subcomponents. This method may be overridden by subclasses to </span>
<span class="sd">        filter or otherwise handle certain subcomponents differently.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">component</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
    
    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Setup Methods </span>
    <span class="c">#--------------------------------------------------------------------------</span></div>
<div class="viewcode-block" id="BaseComponent.setup"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Run the setup process for the ui tree.</span>

<span class="sd">        The setup process is fairly complex and involves multiple steps.</span>
<span class="sd">        The complexity is required in order to ensure a consistent state</span>
<span class="sd">        of the component tree so that default values that are computed </span>
<span class="sd">        from expressions have the necessary information available.</span>

<span class="sd">        The setup process is comprised of the following steps:</span>
<span class="sd">        </span>
<span class="sd">        1)  Abstract objects create their internal toolkit object</span>
<span class="sd">        2)  Abstract objects initialize their internal toolkit object</span>
<span class="sd">        3)  Bound expression values are explicitly applied</span>
<span class="sd">        4)  Abstract objects bind their event handlers</span>
<span class="sd">        5)  Abstract objects are added as listeners to the shell object</span>
<span class="sd">        6)  Visibility is initialized</span>
<span class="sd">        7)  Layout is initialized</span>
<span class="sd">        8)  A finalization pass is made</span>
<span class="sd">        9)  Nodes are marked as initialized</span>
<span class="sd">        </span>
<span class="sd">        Many of these setup methods are no-ops, but are defined on this</span>
<span class="sd">        BaseComponent for simplicity and continuity. Subclasses that</span>
<span class="sd">        need to partake in certain portions of the layout process </span>
<span class="sd">        should re-implement the appropriate setup methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : native toolkit widget, optional</span>
<span class="sd">            If embedding this BaseComponent into a non-Enaml GUI, use </span>
<span class="sd">            this to pass the appropriate toolkit widget that should be </span>
<span class="sd">            the parent toolkit widget for this component.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_create_widgets</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_init_widgets</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_eval_expressions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_bind_widgets</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_listeners</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_init_visibility</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_init_layout</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_finalize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_set_initialized</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_setup_create_widgets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method that, by default, is a no-op. Subclasses </span>
<span class="sd">        that drive gui toolkit widgets should reimplement this method</span>
<span class="sd">        to create the underlying toolkit widget(s).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_create_widgets</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_init_widgets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method that, by default, is a no-op. Subclasses </span>
<span class="sd">        that drive gui toolkit widgets should reimplement this method</span>
<span class="sd">        to initialize their internal toolkit widget(s).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_init_widgets</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_eval_expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method that loops over all of bound expressions and</span>
<span class="sd">        performs a getattr for those attributes. This ensures that all</span>
<span class="sd">        bound attributes are initialized, even if they weren&#39;t implicitly</span>
<span class="sd">        initialized in any of the previous setup methods.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expressions</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_eval_expressions</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_bind_widgets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method that, by default, is a no-op. Subclasses </span>
<span class="sd">        that drive gui toolkit widgets should reimplement this method</span>
<span class="sd">        to bind any event handlers of their internal toolkit widget(s).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_bind_widgets</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_listeners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method that, by default, is a no-op. Subclasses </span>
<span class="sd">        that drive gui toolkit widgets should reimplement this method</span>
<span class="sd">        to setup an traits listeners necessary to drive their internal</span>
<span class="sd">        toolkit widget(s).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_listeners</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_init_visibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method that, by default, is a no-op. Subclasses </span>
<span class="sd">        that drive gui toolkit widgets should reimplement this method</span>
<span class="sd">        to initialize the visibility of their widgets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_init_visibility</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_init_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method that, by default, is a no-op. Subclasses </span>
<span class="sd">        that manage layout should reimplement this method to initialize</span>
<span class="sd">        their underlying layout.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_init_layout</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method that, by default, is a no-op. Subclasses</span>
<span class="sd">        that need to perform process after layout is initialized but</span>
<span class="sd">        before a node is marked as fully initialized should reimplement</span>
<span class="sd">        this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_finalize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_set_initialized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A setup method which updates the initialized attribute of </span>
<span class="sd">        the component to True. This is performed bottom-up.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_setup_set_initialized</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Teardown Methods</span>
    <span class="c">#--------------------------------------------------------------------------</span>
<div class="viewcode-block" id="BaseComponent.destroy"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.destroy">[docs]</a>    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Destroys the component by clearing the list of subcomponents</span>
<span class="sd">        and calling &#39;destroy&#39; on all of the old subcomponents, then gets</span>
<span class="sd">        rid of all references to the subcomponents and bound expressions.</span>
<span class="sd">        Subclasses that need more control over destruction should </span>
<span class="sd">        reimplement this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcomponents</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expressions</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Layout Stubs</span>
    <span class="c">#--------------------------------------------------------------------------</span></div>
<div class="viewcode-block" id="BaseComponent.relayout"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.relayout">[docs]</a>    <span class="k">def</span> <span class="nf">relayout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A method called when the layout of the component&#39;s children</span>
<span class="sd">        should be refreshed. By default, this method proxies the call up</span>
<span class="sd">        the hierarchy until an implementor is found. Any implementors </span>
<span class="sd">        should ensure that the necessary operations take place immediately </span>
<span class="sd">        and are complete before the method returns.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">relayout</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseComponent.request_relayout"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.request_relayout">[docs]</a>    <span class="k">def</span> <span class="nf">request_relayout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A method called when the layout of the component&#39;s children</span>
<span class="sd">        should be refreshed at some point in the future. By default, this </span>
<span class="sd">        method proxies the call up the hierarchy until an implementor is </span>
<span class="sd">        found. Any implementors should ensure that this method returns </span>
<span class="sd">        immediately, and that relayout occurs at some point in the future.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">request_relayout</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseComponent.refresh"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.refresh">[docs]</a>    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A method called when the positioning of the component&#39;s </span>
<span class="sd">        children should be refreshed. By default, this method proxies the </span>
<span class="sd">        call up the hierarchy until an implementor is found. Implementors </span>
<span class="sd">        should ensure that this method takes place immediately, and that</span>
<span class="sd">        the refresh is complete before the method returns. </span>

<span class="sd">        Note: This method should perform less work than &#39;relayout&#39; and </span>
<span class="sd">            should typically only need to be called when the children </span>
<span class="sd">            need to be repositioned, rather than have all of their layout </span>
<span class="sd">            relationships recomputed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="BaseComponent.request_refresh"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.request_refresh">[docs]</a>    <span class="k">def</span> <span class="nf">request_refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A method called when the positioning of the component&#39;s </span>
<span class="sd">        children should be refreshed at some point in the future. By </span>
<span class="sd">        default, this method proxies the call up the hierarchy until an </span>
<span class="sd">        implementor is found. Implementors should ensure that this method </span>
<span class="sd">        returns immediately, and that the refresh is completed at some </span>
<span class="sd">        time in the future.</span>
<span class="sd">        </span>
<span class="sd">        Note: This method should perform less work than &#39;relayout&#39; and </span>
<span class="sd">            should typically only need to be called when the children </span>
<span class="sd">            need to be repositioned, rather than have all of their layout </span>
<span class="sd">            relationships recomputed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">request_refresh</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="BaseComponent.request_relayout_task"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.request_relayout_task">[docs]</a>    <span class="k">def</span> <span class="nf">request_relayout_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Schedule a callback to be executed, followed by a relayout. </span>
<span class="sd">        By default, this method proxies the call up the hierarchy until </span>
<span class="sd">        an implementor is found. Implementors should ensure that the</span>
<span class="sd">        callback is executed with given arguments at some point in the</span>
<span class="sd">        future and is followed by a relayout. It is suggested that </span>
<span class="sd">        implementors collapse multiple calls to this method which</span>
<span class="sd">        results in a single relayout.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">request_relayout_task</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="BaseComponent.request_refresh_task"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.request_refresh_task">[docs]</a>    <span class="k">def</span> <span class="nf">request_refresh_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Schedule a callback to be executed, followed by a rerfresh. </span>
<span class="sd">        By default, this method proxies the call up the hierarchy until </span>
<span class="sd">        an implementor is found. Implementors should ensure that the</span>
<span class="sd">        callback is executed with given arguments at some point in the</span>
<span class="sd">        future and is followed by a relayout. It is suggested that </span>
<span class="sd">        implementors collapse multiple calls to this method which</span>
<span class="sd">        results in a single refresh.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">request_refresh_task</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Bound Attribute Handling</span>
    <span class="c">#--------------------------------------------------------------------------</span></div>
<div class="viewcode-block" id="BaseComponent.add_attribute"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.add_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">add_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr_type</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">is_event</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Adds an attribute to the base component with the given name</span>
<span class="sd">        and ensures that values assigned to this attribute are of a</span>
<span class="sd">        given type.</span>

<span class="sd">        If the object already has an attribute with the given name,</span>
<span class="sd">        an exception will be raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the attribute to add.</span>
<span class="sd">        </span>
<span class="sd">        attr_type : type-like object, optional</span>
<span class="sd">            An object that behaves like a type for the purposes of a</span>
<span class="sd">            call to isinstance. Defaults to object.</span>
<span class="sd">        </span>
<span class="sd">        is_event : bool, optional</span>
<span class="sd">            If True, the added attribute will behave like an event.</span>
<span class="sd">            Otherwise, it will behave like a normal attribute. The </span>
<span class="sd">            default is False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check to see if a trait is already defined. We don&#39;t use</span>
        <span class="c"># hasattr here since that might prematurely trigger a trait</span>
        <span class="c"># intialization. We allow overriding traits of type Disallow,</span>
        <span class="c"># UserAttribute, and UserEvent. The first is a consequence of </span>
        <span class="c"># using HasStrictTraits, where non-existing attributes are </span>
        <span class="c"># manifested as a Disallow trait. The others allow a custom </span>
        <span class="c"># derived component to specialize the attribute and event types </span>
        <span class="c"># of the component from which it is deriving.</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trait</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ttype</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">trait_type</span>
            <span class="n">allowed</span> <span class="o">=</span> <span class="p">(</span><span class="n">UserAttribute</span><span class="p">,</span> <span class="n">UserEvent</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ttype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Disallow</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ttype</span><span class="p">,</span> <span class="n">allowed</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Cannot add &#39;</span><span class="si">%s</span><span class="s">&#39; attribute. The &#39;</span><span class="si">%s</span><span class="s">&#39; attribute on &quot;</span>
                       <span class="s">&quot;the </span><span class="si">%s</span><span class="s"> object already exists.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            
        <span class="c"># At this point we know there are no non-overridable traits </span>
        <span class="c"># defined for the object, but it is possible that there are </span>
        <span class="c"># methods or other non-trait attributes using the given name. </span>
        <span class="c"># We could potentially check for those, but its probably more </span>
        <span class="c"># useful to allow for overriding such things from Enaml, so we </span>
        <span class="c"># just go ahead and add the attribute.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_event</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_trait</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">UserEvent</span><span class="p">(</span><span class="n">attr_type</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_trait</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">UserAttribute</span><span class="p">(</span><span class="n">attr_type</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; is not a valid type for the &#39;</span><span class="si">%s</span><span class="s">&#39; attribute &quot;</span>
                   <span class="s">&quot;declaration on </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseComponent.bind_expression"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.bind_expression">[docs]</a>    <span class="k">def</span> <span class="nf">bind_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">notify_only</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Binds the given expression to the attribute &#39;name&#39;.</span>
<span class="sd">         </span>
<span class="sd">        If the attribute does not exist, an exception is raised. A </span>
<span class="sd">        strong reference to the expression object is kept internally.</span>
<span class="sd">        If the expression is not notify_only and the object is already</span>
<span class="sd">        fully initialized, the value of the expression will be applied</span>
<span class="sd">        immediately.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the attribute on which to bind the expression.</span>
<span class="sd">        </span>
<span class="sd">        expression : AbstractExpression</span>
<span class="sd">            A concrete implementation of AbstractExpression.</span>
<span class="sd">        </span>
<span class="sd">        notify_only : bool, optional</span>
<span class="sd">            If True, the expression is only a notifier, in which case</span>
<span class="sd">            multiple binding is allowed, otherwise the new expression</span>
<span class="sd">            overrides any old non-notify expression. Defaults to False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trait</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">curr</span><span class="o">.</span><span class="n">trait_type</span> <span class="ow">is</span> <span class="n">Disallow</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Cannot bind expression. </span><span class="si">%s</span><span class="s"> object has no attribute &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="c"># If this is the first time an expression is being bound to the</span>
        <span class="c"># given attribute, then we hook up a change handler. This ensures</span>
        <span class="c"># that we only get one notification event per bound attribute.</span>
        <span class="c"># We also create the notification entry in the dict, which is </span>
        <span class="c"># a list with at least one item. The first item will always be</span>
        <span class="c"># the left associative expression (or None) and all following</span>
        <span class="c"># items will be the notify_only expressions.</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expressions</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_trait_change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_bound_attr_changed</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">expressions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

        <span class="c"># There can be multiple notify_only expressions bound to a </span>
        <span class="c"># single attribute, so they just get appended to the end of</span>
        <span class="c"># the list. Otherwise, the left associative expression gets</span>
        <span class="c"># placed at the zero position of the list, overriding any</span>
        <span class="c"># existing expression.</span>
        <span class="k">if</span> <span class="n">notify_only</span><span class="p">:</span>
            <span class="n">expressions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_expression_changed</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">expressions</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">old</span><span class="o">.</span><span class="n">expression_changed</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
            <span class="n">expression</span><span class="o">.</span><span class="n">expression_changed</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
            <span class="n">expressions</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression</span>
        
            <span class="c"># Hookup support for default value computation.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">:</span>
                <span class="c"># We only need to add an ExpressionTrait once, since it </span>
                <span class="c"># will reach back into the _expressions dict as needed</span>
                <span class="c"># and retrieve the bound expression.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">trait_type</span><span class="p">,</span> <span class="n">ExpressionTrait</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_trait</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ExpressionTrait</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># If the component is already initialized, and the given</span>
                <span class="c"># expression supports evaluation, update the attribute </span>
                <span class="c"># with the current value.</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_on_expression_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A private signal callback for the expression_changed signal</span>
<span class="sd">        of the bound expressions. It updates the value of the attribute</span>
<span class="sd">        with the new value from the expression.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_on_bound_attr_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A private handler which is called when any attribute which</span>
<span class="sd">        has a bound signal changes. It calls the notify method on each</span>
<span class="sd">        of the expressions bound to that attribute, but only after the</span>
<span class="sd">        component has been fully initialized.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The check for None is for the case where there are no left </span>
        <span class="c"># associative expressions bound to the attribute, so the first</span>
        <span class="c"># entry in the list is still None.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expressions</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">expr</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Auxiliary Methods </span>
    <span class="c">#--------------------------------------------------------------------------</span>
<div class="viewcode-block" id="BaseComponent.when"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.when">[docs]</a>    <span class="k">def</span> <span class="nf">when</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">switch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A method which returns itself or None based on the truth of</span>
<span class="sd">        the argument.</span>

<span class="sd">        This can be useful to easily turn off the effects of a component</span>
<span class="sd">        if various situations such as constraints-based layout.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        switch : bool</span>
<span class="sd">            A boolean which indicates whether the instance or None </span>
<span class="sd">            should be returned.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : self or None</span>
<span class="sd">            If &#39;switch&#39; is boolean True, self is returned. Otherwise,</span>
<span class="sd">            None is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">switch</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
    </div>
<div class="viewcode-block" id="BaseComponent.traverse"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.traverse">[docs]</a>    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth_first</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Yields all of the nodes in the tree, from this node downward.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        depth_first : bool, optional</span>
<span class="sd">            If True, yield the nodes in depth first order. If False,</span>
<span class="sd">            yield the nodes in breadth first order. Defaults to False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth_first</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="n">stack_pop</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span>
            <span class="n">stack_extend</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">extend</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
            <span class="n">stack_pop</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">popleft</span>
            <span class="n">stack_extend</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">extend</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">stack_pop</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">item</span>
            <span class="n">stack_extend</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="BaseComponent.traverse_ancestors"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.traverse_ancestors">[docs]</a>    <span class="k">def</span> <span class="nf">traverse_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Yields all of the nodes in the tree, from the parent of this </span>
<span class="sd">        node updward, stopping at the given root.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root : BaseComponent, optional</span>
<span class="sd">            The component at which to stop the traversal. Defaults</span>
<span class="sd">            to None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">and</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">parent</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">parent</span>
</div>
<div class="viewcode-block" id="BaseComponent.find_by_name"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.find_by_name">[docs]</a>    <span class="k">def</span> <span class="nf">find_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Locate and return a named item that exists in the subtree</span>
<span class="sd">        which starts at this node.</span>

<span class="sd">        This method will traverse the tree of components, breadth first,</span>
<span class="sd">        from this point downward, looking for a component with the given</span>
<span class="sd">        name. The first one with the given name is returned, or None if</span>
<span class="sd">        no component is found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the component for which to search.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : BaseComponent or None</span>
<span class="sd">            The first component found with the given name, or None if </span>
<span class="sd">            no component is found.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cmpnt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">cmpnt</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cmpnt</span>
</div>
<div class="viewcode-block" id="BaseComponent.toplevel_component"><a class="viewcode-back" href="../../../api_ref/widgets/enaml.core.base_component.BaseComponent.html#enaml.core.base_component.BaseComponent.toplevel_component">[docs]</a>    <span class="k">def</span> <span class="nf">toplevel_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Walks up the tree of components starting at this node and</span>
<span class="sd">        returns the toplevel node, which is the first node encountered</span>
<span class="sd">        without a parent.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cmpnt</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">cmpnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">cmpnt</span>
            <span class="n">cmpnt</span> <span class="o">=</span> <span class="n">cmpnt</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="n">res</span>
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../enaml-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">enaml 0.2alpha documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
  
    <li><a href="#">enaml.core.base_component</a></li>
  

      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Enthought, Inc..
      Last updated on Jun 12, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>