


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Design and Architecture &mdash; enaml 0.3alpha documentation</title>
    
    <link rel="stylesheet" href="../_static/enthought_doc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.3alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/et.ico"/>
    <link rel="top" title="enaml 0.3alpha documentation" href="../index.html" />
    <link rel="up" title="Enaml Architecture Reference" href="index.html" />
    <link rel="next" title="Enaml API Reference" href="../api_ref/index.html" />
    <link rel="prev" title="Enaml Architecture Reference" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../enaml-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../api_ref/index.html" title="Enaml API Reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Enaml Architecture Reference"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">enaml 0.3alpha documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Enaml Architecture Reference</a> &raquo;</li>
  
    <li><a href="#">Design and Architecture</a></li>
  

      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/e-logo-rev.png" alt="Logo"/>
            </a></p>
<h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">Design and Architecture</a><ul>
<li><a class="reference internal" href="#construction-of-a-view">Construction of a View</a></li>
<li><a class="reference internal" href="#adding-new-widgets">Adding New Widgets</a></li>
<li><a class="reference internal" href="#implementing-a-new-toolkit">Implementing A New Toolkit</a></li>
<li><a class="reference internal" href="#using-a-different-notification-model">Using A Different Notification Model</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/architecture/architecture.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="design-and-architecture">
<h1>Design and Architecture<a class="headerlink" href="#design-and-architecture" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This documentation is not current and does not reflect the way
Enaml currently works.</p>
</div>
<p>Enaml is designed with a flexible, open architecture.  It is designed to be
able to adapt to different UI toolkit backends beyond the currently supported
Qt and Wx backends, as well as allowing other key parts of the infrastructure
to be replaced.</p>
<div class="section" id="construction-of-a-view">
<h2>Construction of a View<a class="headerlink" href="#construction-of-a-view" title="Permalink to this headline">¶</a></h2>
<p>When building a view, you typically will create it via a sequence of commands
like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">enaml</span>

<span class="k">with</span> <span class="n">enaml</span><span class="o">.</span><span class="n">imports</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">my_enaml_module</span> <span class="kn">import</span> <span class="n">MyView</span>

<span class="n">view</span> <span class="o">=</span> <span class="n">MyView</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">view</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The import step parses and compiles the Enaml file, creating a Python module
containing view factories which can be used by importing the appropriate
name.  When called, these views factories expect model objects to be passed
via arguments and then use the UI toolkit to construct the actual UI components
that will be used in the view.  Finally the show() method starts the application
mainloop if needed and makes the UI components visible.</p>
<p>The enaml.imports() context manager provides an import hook that detects when an
<tt class="docutils literal"><span class="pre">.enaml</span></tt> file is being imported, parses it into an Enaml AST and uses
<tt class="xref py py-class docutils literal"><span class="pre">EnamlCompiler</span></tt> to compile it to Enaml
bytecode. From the importer&#8217;s point of view it creates a standard Python module
which has one or more <tt class="xref py py-class docutils literal"><span class="pre">EnamlDefinition</span></tt> objects which create
re-usable UI templates.  The <tt class="xref py py-class docutils literal"><span class="pre">EnamlDefinition</span></tt> objects can be used by
other Enaml modules which import them, or directly by Python code.  Each
<tt class="xref py py-class docutils literal"><span class="pre">EnamlDefinition</span></tt> instance is a namespace which can have additional
variable values supplied as arguments when it is called.</p>
<p>Calling an <tt class="xref py py-class docutils literal"><span class="pre">EnamlDefinition</span></tt> object uses the supplied arguments to
build its namespace and then executes the Enaml bytecode to construct the UI
shell components.  The UI shell components are toolkit independent traited
classes which expose the functionality of a toolkit widget in a uniform manner.
The toolkit specific widget wrapper objects are managed internally by the
shell components. Both of these objects are created through the use of special
Toolkit objects. Normally the Toolkit object to use is inferred from the user&#8217;s
environment variables, but a particular toolkit can be selected using a context
manager:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">enaml.toolkit</span> <span class="kn">import</span> <span class="n">wx_toolkit</span>

<span class="k">with</span> <span class="n">wx_tookit</span><span class="p">():</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">MyView</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<span class="n">view</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally the show() call on the view object recursively creates the underlying
gui toolkit widgets by following a formalized set process. This process calls
the following methods on each component in the tree in a top-down fashion:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">create()</span></tt> method to create the gui toolkit widget</li>
<li><tt class="docutils literal"><span class="pre">initialize()</span></tt> method to set the initial state of the gui toolkit widget</li>
<li><tt class="docutils literal"><span class="pre">bind()</span></tt> method to bind event handlers (or the toolkit equivalents)</li>
</ul>
<p>In addition, widgets which participate in constraints-based layout will have
methods called to register their constraints with the appropriate constraint
solvers, and then solve the layout.</p>
</div>
<div class="section" id="adding-new-widgets">
<h2>Adding New Widgets<a class="headerlink" href="#adding-new-widgets" title="Permalink to this headline">¶</a></h2>
<p>These layers of abstraction and delegation mean that it is fairly simple to add
new widget types in custom applications.  To create a new widget, one needs to:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Optionally, but ideally, define the abstract interface for your
widget, which should be at least a subclass of the abstract base class
<tt class="xref py py-class docutils literal"><span class="pre">AbstractTkBaseComponent</span></tt>
but will likely be a subclass of
<tt class="xref py py-class docutils literal"><span class="pre">AbstractTkControl</span></tt> or
<tt class="xref py py-class docutils literal"><span class="pre">AbstractTkContainer</span></tt>.
Since this is an abstract base class, you shouldn&#8217;t implement any of the
functionality in this class.</p>
<p>This class provides the generic API the individual toolkit backends will
need to implement, and will provide the methods that the Enaml widget
will call in order to communicate with the gui toolkit widget.  In
particular, there needs to be a specially named
<tt class="xref py py-meth docutils literal"><span class="pre">shell_*_changed(self,</span> <span class="pre">value)()</span></tt> change handler for every
dynamic Trait on the Enaml shell version of the Widget. These methods
will allow the toolkit widget to appropriately react to changes from
the user&#8217;s code.</p>
</li>
<li><p class="first">Create the Enaml shell version of the Widget.  This will at least be a
subclass of <tt class="xref py py-class docutils literal"><span class="pre">BaseComponent</span></tt>,
and most likely a subclass of <tt class="xref py py-class docutils literal"><span class="pre">Control</span></tt>
or <tt class="xref py py-class docutils literal"><span class="pre">AbstractTkContainer</span></tt>.  This class
defines the interface that the Enaml markup language sees and can use.
There should be, at a minimum, traits corresponding to values that can
be read or changed on the widget, as well as methods for all standard
actions for which access should be supplied.</p>
<p>This class is not abstract, and should provide all the functionality
required in a toolkit-independent manner.  This must define a trait
called <tt class="xref py py-attr docutils literal"><span class="pre">abstract_obj</span></tt> which is an <tt class="xref py py-class docutils literal"><span class="pre">Instance()</span></tt> of
the implementation interface defined in the previous step.</p>
</li>
<li><p class="first">Create a version of the Widget for each backend that you need to support.
Each of these will be a subclass of the appropriate backend-specific
component, such as <tt class="xref py py-class docutils literal"><span class="pre">WXBaseComponent</span></tt>
or  <tt class="xref py py-class docutils literal"><span class="pre">QtBaseComponent</span></tt> as well as
subclassing the abstract interface defined in the first step.  Once again,
these are most likely to be subclasses of the appropriate Control classes.</p>
<p>Instances of this class will have a <tt class="xref py py-attr docutils literal"><span class="pre">shell_obj</span></tt> attribute
which provides a reference to the Enaml shell widget instance for that
control so that values can be obtained and inspected. This attribute
is provided by the base class and will normally not need to be overridden.</p>
<p>This class must then, obviously, provide a concrete implemetation of the
abstract interface.  In particular, it must provide the following methods
(even if they are no-ops or implemented in a superclass):</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="xref py py-meth docutils literal"><span class="pre">create(self)()</span></tt></dt>
<dd><p class="first">This is responsible for creating the underlying toolkit objects
or widgets that the Enaml shell widget requires as part of its UI.
e.g. create the QPushButton or wx.Button widget.</p>
<p class="last">You will almost always have to write this method.</p>
</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">initialize(self)()</span></tt></dt>
<dd><p class="first">This is responsible for initializing the state of the toolkit
object or objects based on the state of the Enaml shell widget.</p>
<p class="last">You will almost always have to write this method.</p>
</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">bind(self)()</span></tt></dt>
<dd><p class="first">This is responsible for setting up the initial bindings of
toolkit events to handlers on this object.</p>
<p class="last">You will almost always have to write this method.</p>
</dd>
</dl>
</div></blockquote>
<p>If you are writing a composite widget which contains a collection of
toolkit widgets, as opposided to a single control-style widget, you
may need to override the following:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="xref py py-meth docutils literal"><span class="pre">size_hint(self)()</span></tt></dt>
<dd><p class="first last">This is responsible for returning a suggested size for the widget
in its current state for use by the layout manager.</p>
</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">set_geometry(self,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">width,</span> <span class="pre">height)()</span></tt></dt>
<dd><p class="first last">This method is called when the layout system needs to re-position
or resize the widget.  For a simple single widget control, this
would usually just call the appropriate set geometry method on
the underlying toolkit widget, but for an Enaml widget composed
of multiple toolkit widgets you will need to lay them out
relative to each other and the space that they have been provided.</p>
</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">move(self,</span> <span class="pre">x,</span> <span class="pre">y)()</span></tt></dt>
<dd><p class="first last">A position-only version of <tt class="xref py py-meth docutils literal"><span class="pre">set_geometry(...)()</span></tt></p>
</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">resize(self,</span> <span class="pre">width,</span> <span class="pre">height)()</span></tt></dt>
<dd><p class="first last">A size-only version of <tt class="xref py py-meth docutils literal"><span class="pre">set_geometry(...)()</span></tt></p>
</dd>
</dl>
</div></blockquote>
<p>In addition to these standard methods, you will need to provide
implementations for each of the methods you declared in the first step:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="xref py py-meth docutils literal"><span class="pre">shell_*_changed(self,</span> <span class="pre">value)()</span></tt></dt>
<dd><p class="first last">This has to react to a change to the appropriate trait on the
Enaml widget and change the appropriate toolkit state.</p>
</dd>
</dl>
</div></blockquote>
<p>as well as any other methods that may be needed.</p>
<p>If you are writing a control, you may need to handle error and exceptions
generated by invalid values, either coming in to the widget from the
underlying model, or from values entered by the user.  The
<tt class="xref py py-class docutils literal"><span class="pre">enaml.widgets.control.Control</span></tt> class provides a standard API
for registering these:</p>
<div class="highlight-python"><pre>:py:attr:`error`
    This is a boolean trait which is True if an invalid value was
    entered.

:py:attr:`exception`
    This is a trait which holds the Exception object that caused
    the error to be flagged.</pre>
</div>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">enaml.widgets.control.Control</span></tt> class provides two helper
contexts which can be used to automatically capture any exceptions:</p>
<div class="highlight-python"><pre>:py:meth:`capture_exceptions`
    This will capture any exceptions generated by a block of code
    in a with statement, and will automatically set or clear the
    error state appropriately.  Because of the way that exceptions
    work in trait notification handlers, this may fail to capture
    errors generated by delegation or notification expresssions.

:py:meth:`capture_notification_exceptions`
    This will capture any exceptions including exceptions generated
    in notification handlers fired by traits in response to changes
    within code in a with statement.</pre>
</div>
<p>Finally, to assist in debugging and logging, the toolkit object has a
<tt class="xref py py-attr docutils literal"><span class="pre">control_exception_handler</span></tt> callback that can be supplied which
will be called with a single argument which is an exception captured by
either of the above contexts.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">These methods are outdated and for the moment is only a placeholder</p>
</div>
<p>To handle styling</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="xref py py-meth docutils literal"><span class="pre">create_style_handler(self)()</span></tt></dt>
<dd><p class="first">This is responsible for creating a <tt class="xref py py-class docutils literal"><span class="pre">StyleHandler</span></tt>
instance.  You may need to implement a custom subclass of
<tt class="xref py py-class docutils literal"><span class="pre">StyleHandler</span></tt> if your widget has unusual styling
needs.</p>
<p class="last">If your styling needs are simple, you may be able to
define an appropriate <tt class="xref py py-attr docutils literal"><span class="pre">tags</span></tt> class attribute which
maps supported style tags to toolkit-dependent information,
and use the default implementation of the method from the
toolkit.</p>
</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">initialize_style(self)()</span></tt></dt>
<dd><p class="first">This method is responsible for initializing the values on the
<tt class="xref py py-class docutils literal"><span class="pre">StyleHandler</span></tt> class created by the previous method.</p>
<p class="last">If your styling needs are simple, you may be able to use the
default toolkit implementation of this class.</p>
</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">layout_child_widgets(self)()</span></tt></dt>
<dd><p class="first last">This method is used by <tt class="xref py py-class docutils literal"><span class="pre">Container</span></tt> implementations to
insert child widgets into the appropriate toolkit-specific
layout object, and set the appropriate attributes and properties
of this object.  Most simple Control subclasses do not need to
implement this, since they do not have child widgets.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">Create the toolkit constructor and add it to the appropriate toolkit
object.  There are several ways to do this, depending on your goals:</p>
<blockquote>
<div><ul>
<li><p class="first">if you are adding a new control type to the main Enaml source,
then you can directly create a constructor in the toolkit&#8217;s
<tt class="docutils literal"><span class="pre">constructors.py</span></tt> module.  This module contains a dictionary
of constructors and a utility function for building them
assuming that you have followed a naming pattern for your classes
which is consistent with the rest of the toolkit widgets.</p>
<p>Typically this will look something like:</p>
<div class="highlight-python"><pre>QT_CONSTRUCTORS = dict((
    ...
    constructor('my_new_widget'),
))</pre>
</div>
</li>
<li><p class="first">if you are adding a new control type that is specific to your
code and not part of the main Enaml system, then you will need
to manually create an <tt class="xref py py-class docutils literal"><span class="pre">Constructor</span></tt>
instance and add it to an appropriate toolkit.  Building a
constructor is simply a matter of creating a new
<tt class="xref py py-class docutils literal"><span class="pre">Constructor</span></tt> with your Enaml shell
class from step (2) and your toolkit backend class from step (3).</p>
<p>Typical code for this would look like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">enaml.toolkit</span> <span class="kn">import</span> <span class="n">Constructor</span>

<span class="k">def</span> <span class="nf">my_new_widget</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">my_widgets.my_new_widgets</span> <span class="kn">import</span> <span class="n">MyNewWidget</span>
    <span class="k">return</span> <span class="n">MyNewWidget</span>

<span class="k">def</span> <span class="nf">my_new_qt_widget</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">my_widgets.qt.qt_my_new_widgets</span> <span class="kn">import</span> <span class="n">QtMyNewWidget</span>

<span class="n">ctor</span> <span class="o">=</span> <span class="n">Constructor</span><span class="p">(</span><span class="n">my_new_widget</span><span class="p">,</span> <span class="n">my_new_qt_widget</span><span class="p">)</span>
</pre></div>
</div>
<p>The items passed to the Constructor are callables which return
the appropriate classes, so that importing of the necessary
modules can be delayed until the objects actually need to be
used. This helps to drastically reduce runtime overhead for
simple applications which only use a small portion of a ui
toolkit.</p>
<p>Once you have the constructor you need to add it to a toolkit.
If you want this to be globally available in your process as part
of the appropriate toolkit then you need to add it to the toolkit&#8217;s
constructor dictionary before you create any views:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">enaml.widgets.qt.constructors</span> <span class="kn">import</span> <span class="n">QT_CONSTRUCTORS</span>

<span class="n">QT_CONSTRUCTORS</span><span class="p">[</span><span class="s">&#39;MyNewWidget&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctor</span>
</pre></div>
</div>
<p>Any subsequent calls to <tt class="xref py py-func docutils literal"><span class="pre">qt_toolkit()</span></tt> will
now contain your new widget.</p>
<p>Alternatively, you may want to create your own toolkit that is
separate from the usual backend toolkit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">enaml.toolkit</span> <span class="kn">import</span> <span class="n">qt_toolkit</span>

<span class="n">my_toolkit</span> <span class="o">=</span> <span class="n">qt_toolkit</span><span class="p">()</span>
<span class="n">my_toolkit</span><span class="p">[</span><span class="s">&#39;MyNewWidget&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctor</span>
</pre></div>
</div>
<p>This will create a new toolkit which has all of the widgets in
the standard Qt toolkit, but also includes yours.  Code can then
choose whether to use the standard Qt toolkit or your new toolkit
as appropriate.</p>
</li>
<li><p class="first">There is a convienence built into the constructors for the cases
where a custom widget is only a simple subclass of an existing
shell component. Suppose we wish to create a FloatField which
is a simple subclass of Field that hard-codes the converter
object to a float converter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">traits.api</span> <span class="kn">import</span> <span class="n">Constant</span>

<span class="kn">from</span> <span class="nn">enaml.converters</span> <span class="kn">import</span> <span class="n">FloatConverter</span>
<span class="kn">from</span> <span class="nn">enaml.widgets.field</span> <span class="kn">import</span> <span class="n">Field</span>

<span class="k">class</span> <span class="nc">FloatField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>

    <span class="n">converter</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">FloatConverter</span><span class="p">())</span>
</pre></div>
</div>
<p>It would be silly to require the definition of a new
toolkit implementation class for each backend, since the
implementation class doesn&#8217;t need to change. Instead, we
can make sure that our new subclass uses the appropriate
implementation but creating a clone of its constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">enaml.toolkits</span> <span class="kn">import</span> <span class="n">qt_toolkit</span>

<span class="k">def</span> <span class="nf">my_float_field</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">FloatField</span>

<span class="n">my_toolkit</span> <span class="o">=</span> <span class="n">qt_toolkit</span><span class="p">()</span>

<span class="n">field_constructor</span> <span class="o">=</span> <span class="n">my_toolkit</span><span class="p">[</span><span class="s">&#39;Field&#39;</span><span class="p">]</span>

<span class="n">my_constructor</span> <span class="o">=</span> <span class="n">field_constructor</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">my_float_field</span><span class="p">)</span>

<span class="n">my_toolkit</span><span class="p">[</span><span class="s">&#39;FloatField&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_constructor</span>
</pre></div>
</div>
<p>This toolkit will now always be sure to use the proper
toolkit widget for the FloatField.</p>
</li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="implementing-a-new-toolkit">
<h2>Implementing A New Toolkit<a class="headerlink" href="#implementing-a-new-toolkit" title="Permalink to this headline">¶</a></h2>
<p>Currently, Enaml supports the Qt toolkit and the Wx toolkit (Wx officially on
Windows only). The architecture is designed to be as toolkit-independent as
possible.  To implement a new toolkit, you will need to perform the following
steps:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Create a constructor dictionary for your toolkit.  You should be able
to take the <tt class="docutils literal"><span class="pre">constructor.py</span></tt> module from either the Qt or Wx backends
and modify the constructor factory function to import from the correct
packages and mangle the class names appropriately.</p>
</li>
<li><p class="first">Create a default stylesheet for your toolkit.  Initially it may be
sufficient to copy the stylesheet for an existing backend, since the
stylesheet definitions are toolkit-independent.</p>
</li>
<li><p class="first">Create a new toolkit factory for your new backend.  This should look
something like the current <tt class="xref py py-class docutils literal"><span class="pre">enaml.toolkit.wx_toolkit</span></tt> or
<tt class="xref py py-class docutils literal"><span class="pre">enaml.toolkit.qt_toolkit</span></tt> factories.  This factory should
create a Toolkit instance, which is a dictionary subclass whose keys
are the available Enaml entity names.  Usually this will consist of the
toolkit&#8217;s constructor dictionary from (1) together with the standard
<tt class="docutils literal"><span class="pre">OPERATORS</span></tt> from <tt class="xref py py-mod docutils literal"><span class="pre">enaml.toolkit</span></tt> and a <tt class="docutils literal"><span class="pre">utils</span></tt> dictionary.
In additon the following attributes need to be supplied with callables:</p>
<div class="highlight-python"><pre>:py:attr:`create_app`
    A function that is responsible for obtaining (or creating, if it
    doesn't yet exist) the main toolkit application object, or
    otherwise performing whatever initialization is needed to allow
    widgets to be created.  It should not start the main event loop,
    however.

    This should return the application object, if appropriate.

:py:attr:`start_app`
    A function that takes an application object returned by
    :py:attr:`create_app` and starts the main event loop.

:py:attr:`style_sheet`
    The default stylesheet for your toolkit.</pre>
</div>
</li>
<li><p class="first">Write toolkit-specific implementations of each Enaml widget.  See the
previous section for discussion for the methods that you will need to
implement on this class.</p>
<p>This is where the bulk of the work will be performed.</p>
</li>
<li><p class="first">Write the implementations of auxilliary objects, such as dialog windows.</p>
</li>
</ol>
</div></blockquote>
<p>If all of the above steps are performed correctly, you should be able to display
any Enaml UI in your new toolkit.</p>
</div>
<div class="section" id="using-a-different-notification-model">
<h2>Using A Different Notification Model<a class="headerlink" href="#using-a-different-notification-model" title="Permalink to this headline">¶</a></h2>
<p>Enaml uses Enthought&#8217;s Traits system by default for handling binding and
notification of expressions to model attributes.  You may have existing code
which uses a different system for reacting to changes within the model, and
Enaml can be extended to be able to use these systems as well.  This would
allow developers to write code which might do things like access a model on
a remote machine, or stored in a database.</p>
<p>To support this sort of behaviour, you will probably want to have a base class
that all model objects with this new reaction mechanism inherit from, or some
other simple way that these model instances can be distinguished from regular
Python or Traits instances.</p>
<p>You may then need to implement subclasses of
<tt class="xref py py-class docutils literal"><span class="pre">enaml.expressions.AbstractExpression</span></tt> that correctly handle the
interactions that your notification system supports for its models.  These
subclasses will need to implement appropriate versions of the <tt class="xref py py-meth docutils literal"><span class="pre">bind()</span></tt>
and <tt class="xref py py-meth docutils literal"><span class="pre">eval_expression()</span></tt> methods.</p>
<p>For the four basic expression bindings, you will most likely need to create
subclasses of  <tt class="xref py py-class docutils literal"><span class="pre">enaml.expressions.SimpleExpression</span></tt>,
<tt class="xref py py-class docutils literal"><span class="pre">enaml.expressions.UpdatingExpression</span></tt>,
<tt class="xref py py-class docutils literal"><span class="pre">enaml.expressions.DelegatingExpression</span></tt>, and
<tt class="xref py py-class docutils literal"><span class="pre">enaml.expressions.NotifyingExpression</span></tt>.
When implementing overriden methods, all of these subclasses
must check to see whether the model object is of the new model type, and if
it is not then they need to fall back to using the standard superclass
implementation of the method.  If this is not done then expressions involving
widget traits will fail to work correctly.</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="xref py py-class docutils literal"><span class="pre">SimpleExpression</span></tt></dt>
<dd><p class="first">This class needs to be able to provide a default value for the
expression, but does not need to react to changes in the model object
or in the Enaml namespace.</p>
<p class="last">You may need to override the <tt class="xref py py-meth docutils literal"><span class="pre">eval_expression()</span></tt> handler
to compute the default value from the model, but ideally you should
be able to use this class unmodified.</p>
</dd>
<dt><tt class="xref py py-class docutils literal"><span class="pre">UpdatingExpression</span></tt></dt>
<dd><p class="first">This class needs to provide a default value for the expression, but
also needs to analyze the expression for dependencies and react to
changes in the dependency values on the model objects.</p>
<p>You may need to override the <tt class="xref py py-meth docutils literal"><span class="pre">eval_expression()</span></tt> handler
to as in the <tt class="xref py py-class docutils literal"><span class="pre">DefaultExpression</span></tt> case,
but again hopefully the default will be sufficient.</p>
<p class="last">You will also need to override the <tt class="xref py py-meth docutils literal"><span class="pre">bind()</span></tt> method to correctly
hook up the expression to its dependencies in your model&#8217;s notification
model.  This is likely to require walking the provided expression AST
to determine dependencies (the AttributeVisitor class may be useful
for this) and you may have to register callbacks on an appropriate
object.  This callback will probably look something like the
<tt class="xref py py-meth docutils literal"><span class="pre">update_object()</span></tt> method, but may need to perform additional
steps depending on your model.</p>
</dd>
<dt><tt class="xref py py-class docutils literal"><span class="pre">NotifyingExpression</span></tt></dt>
<dd><p class="first">This class requires the ability to execute a code expression whenever
an Enaml attribute changes.</p>
<p class="last">You may need to override the <tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt> method to compute the
expression correctly, but ideally you should be able to use this
class unmodified.</p>
</dd>
<dt><tt class="xref py py-class docutils literal"><span class="pre">DelegatingExpression</span></tt></dt>
<dd><p class="first">This class requires both the ability to analyze and react to changes
in expression dependencies, but also push changes from the Enaml
trait which it is connected to onto the designated object.</p>
<p>This will require an appropriate <tt class="xref py py-meth docutils literal"><span class="pre">bind()</span></tt> method similar to
the one that the <tt class="xref py py-class docutils literal"><span class="pre">BindingExpression</span></tt> uses,
although the allowable expressions are much simpler for
<tt class="xref py py-class docutils literal"><span class="pre">DelegatingExpression</span></tt>.</p>
<p class="last">You will also need to override the implementations of
<tt class="xref py py-meth docutils literal"><span class="pre">update_object()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">update_delegate()</span></tt> to
appropriately change the value on the underlying model.</p>
</dd>
</dl>
</div></blockquote>
<p>Having written these classes, you will need to define operator factories for
each of them and override your toolkit&#8217;s <tt class="docutils literal"><span class="pre">OPERATORS</span></tt>, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">enaml.operators</span> <span class="kn">import</span> <span class="n">operator_factory</span><span class="p">,</span> <span class="n">OPERATORS</span>

<span class="n">OPERATORS</span><span class="p">[</span><span class="s">&#39;__operator_LessLess__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator_factory</span><span class="p">(</span><span class="n">MyUpdatingExpression</span><span class="p">)</span>
</pre></div>
</div>
<p>If it makes sense for your new expression to use a different operator than the
standard four, you can define a different name and then the corresponding
operator will be available, for example to enable <tt class="docutils literal"><span class="pre">&lt;&lt;&lt;</span></tt> as an operator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">OPERATORS</span><span class="p">[</span><span class="s">&#39;__operator_LessLessLess__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator_factory</span><span class="p">(</span><span class="n">MyUpdatingExpression</span><span class="p">)</span>
</pre></div>
</div>
<p>The above changes will be global in nature.  If you want to restrict the modified
operators to a subset of code, you can create an instance of at Toolkit object
and override the operators in just that instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">enaml.operators</span> <span class="kn">import</span> <span class="n">operator_factory</span>
<span class="kn">from</span> <span class="nn">enaml.toolkit</span> <span class="kn">import</span> <span class="n">qt_toolkit</span>

<span class="n">my_toolkit</span> <span class="o">=</span> <span class="n">qt_toolkit</span><span class="p">()</span>
<span class="n">my_toolkit</span><span class="p">[</span><span class="s">&#39;__operator_LessLess__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator_factory</span><span class="p">(</span><span class="n">MyUpdatingExpression</span><span class="p">)</span>
</pre></div>
</div>
<p>Or for even more fine grained control (and are accepting or horrible, horrible
hacks) then you can pass in an operator as a local variable to an EnamlDefinition:</p>
<div class="highlight-python"><pre>enamldef MainWindow(my_model, __operator_LessLessLess__):
    Window:
        PushButton:
            # The &lt;&lt;&lt; operator is resolved to the 2nd argument
            # to MainWindow
            text &lt;&lt;&lt; my_model.foo</pre>
</div>
<p>This could also be a keyword argument if desired, or even a module level
python function. That is, operators resolved using the same scope rules as
the rest of the Enaml file.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../enaml-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../api_ref/index.html" title="Enaml API Reference"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Enaml Architecture Reference"
             >previous</a> |</li>
        <li><a href="../index.html">enaml 0.3alpha documentation</a> &raquo;</li>
          <li><a href="index.html" >Enaml Architecture Reference</a> &raquo;</li>
  
    <li><a href="#">Design and Architecture</a></li>
  

      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Enthought, Inc..
      Last updated on Sep 11, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>