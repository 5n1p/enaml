


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>enaml.core.declarative &mdash; enaml 0.3alpha documentation</title>
    
    <link rel="stylesheet" href="../../../_static/enthought_doc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/et.ico"/>
    <link rel="top" title="enaml 0.3alpha documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../enaml-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">enaml 0.3alpha documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li>
  
    <li><a href="#">enaml.core.declarative</a></li>
  

      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/e-logo-rev.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for enaml.core.declarative</h1><div class="highlight"><pre>
<span class="c">#------------------------------------------------------------------------------</span>
<span class="c">#  Copyright (c) 2012, Enthought, Inc.</span>
<span class="c">#  All rights reserved.</span>
<span class="c">#------------------------------------------------------------------------------</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">traits.api</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">HasStrictTraits</span><span class="p">,</span> <span class="n">Instance</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Property</span><span class="p">,</span> <span class="n">Str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Disallow</span><span class="p">,</span> <span class="n">Bool</span><span class="p">,</span>
    <span class="n">Undefined</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.expressions</span> <span class="kn">import</span> <span class="n">AbstractExpression</span>
<span class="kn">from</span> <span class="nn">.operator_context</span> <span class="kn">import</span> <span class="n">OperatorContext</span>
<span class="kn">from</span> <span class="nn">.trait_types</span> <span class="kn">import</span> <span class="n">EnamlEvent</span><span class="p">,</span> <span class="n">ExpressionTrait</span><span class="p">,</span> <span class="n">UserAttribute</span><span class="p">,</span> <span class="n">UserEvent</span>


<span class="c">#: The traits types on an Declarative instance which can be overridden</span>
<span class="c">#: by the user in an enamldef declaration.</span>
<span class="n">_OVERRIDE_ALLOWED</span> <span class="o">=</span> <span class="p">(</span><span class="n">UserAttribute</span><span class="p">,</span> <span class="n">UserEvent</span><span class="p">)</span>


<div class="viewcode-block" id="Declarative"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative">[docs]</a><span class="k">class</span> <span class="nc">Declarative</span><span class="p">(</span><span class="n">HasStrictTraits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The most base class of the Enaml component hierarchy.</span>

<span class="sd">    This class provides the core functionality required of declarative</span>
<span class="sd">    Enaml types. It can be used directly in an Enaml component tree</span>
<span class="sd">    to store and react to state changes just like any other component.</span>
<span class="sd">    However, it has no concept of visual representation or client</span>
<span class="sd">    communication. That functionality is added by subclasses.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#: An optional name to give to this component to assist in finding</span>
    <span class="c">#: it in the tree. See e.g. the &#39;find&#39; method.</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Str</span>

    <span class="c">#: A readonly property which returns the instance&#39;s class name.</span>
    <span class="n">class_name</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="c">#: A readonly property which returns the names of the instances</span>
    <span class="c">#: base classes, stopping at Declarative.</span>
    <span class="n">base_names</span> <span class="o">=</span> <span class="n">Property</span>

    <span class="c">#: A readonly property which returns the current instance of the</span>
    <span class="c">#: component. This allows declarative Enaml expressions to access</span>
    <span class="c">#: &#39;self&#39; according to Enaml&#39;s dynamic scoping rules.</span>
    <span class="bp">self</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c">#: The parent component of this component. It is stored internally</span>
    <span class="c">#: as a weakref to mitigate issues with reference cycles. </span>
    <span class="c">#: XXX store these strongly for now, traits gets notification</span>
    <span class="c">#: errors on shutdown when the weakrefs die. grr....</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="s">&#39;Declarative&#39;</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c">#: The list of children for this component. </span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">Instance</span><span class="p">(</span><span class="s">&#39;Declarative&#39;</span><span class="p">))</span>

    <span class="c">#: An event emitted when the list of children for this component</span>
    <span class="c">#: changes, either in whole or in place. The payload of the event</span>
    <span class="c">#: is a dict with the keys &#39;added&#39; and &#39;removed&#39;. The value for </span>
    <span class="c">#: the &#39;added&#39; key is a list of 2-tuples of (idx, item) where &#39;idx&#39;</span>
    <span class="c">#: is the new location of &#39;item&#39; in the list of children. The value</span>
    <span class="c">#: of the &#39;removed&#39; key is a list of removed items. This event is</span>
    <span class="c">#: emitted once all reparenting operations for all of the children</span>
    <span class="c">#: are complete.</span>
    <span class="n">children_changed</span> <span class="o">=</span> <span class="n">EnamlEvent</span>

    <span class="c">#: manipulated by user code.</span>
    <span class="n">initialized</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

    <span class="c">#: An event fired during the post init traversal. This allows </span>
    <span class="c">#: any declarative bindings to perform any necessary procedural</span>
    <span class="c">#: initialization, such as initializing dynamic children.</span>
    <span class="n">inited</span> <span class="o">=</span> <span class="n">EnamlEvent</span>

    <span class="c">#: The private dictionary of expression objects that are bound to </span>
    <span class="c">#: attributes on this component. It should not be manipulated by</span>
    <span class="c">#: user code. Rather, expressions should be bound by the operators</span>
    <span class="c">#: by calling the &#39;_bind_expression&#39; method.</span>
    <span class="n">_expressions</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">(</span><span class="n">Str</span><span class="p">,</span> <span class="n">List</span><span class="p">(</span><span class="n">Instance</span><span class="p">(</span><span class="n">AbstractExpression</span><span class="p">)))</span>

    <span class="c">#: A class attribute used by the Enaml compiler machinery to store</span>
    <span class="c">#: the builder functions on the class. The functions are called</span>
    <span class="c">#: when a component is instantiated and are the mechanism by which</span>
    <span class="c">#: a component is populated with its declarative children and bound</span>
    <span class="c">#: expression objects.</span>
    <span class="n">_builders</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c">#: The HasTraits class defines a class attribute &#39;set&#39; which is</span>
    <span class="c">#: a deprecated alias for the &#39;trait_set&#39; method. The problem</span>
    <span class="c">#: is that having that as an attribute interferes with the </span>
    <span class="c">#: ability of Enaml expressions to resolve the builtin &#39;set&#39;,</span>
    <span class="c">#: since the dynamic attribute scoping takes precedence over</span>
    <span class="c">#: builtins. This resets those ill-effects.</span>
    <span class="nb">set</span> <span class="o">=</span> <span class="n">Disallow</span>

<div class="viewcode-block" id="Declarative.__init__"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize a declarative component.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : Declarative or None, optional</span>
<span class="sd">            The Declarative component instance which is the parent of </span>
<span class="sd">            this component, or None if the component has no parent.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Any other positional arguments needed to initialize the</span>
<span class="sd">            component.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Declarative</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="c"># Set the parent reference on the object. We do this quietly</span>
        <span class="c"># so that the _parent_changed handler is not invoked. This </span>
        <span class="c"># saves us a linear scan over the parent&#39;s children since we</span>
        <span class="c"># can be reasonably sure that this child has not yet been</span>
        <span class="c"># added as a child of the parent.</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trait_setq</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># If any builders are present, they need to be invoked before</span>
        <span class="c"># applying any other keyword arguments so that bound expressions</span>
        <span class="c"># do not override the keywords. The builders appear and are run</span>
        <span class="c"># in the reverse order of a typical mro. The most base builder</span>
        <span class="c"># gets to add its children and bind its expressions first. </span>
        <span class="c"># Builders that come later can then override these bindings.</span>
        <span class="c"># Each component gets it&#39;s own identifier namespace and current</span>
        <span class="c"># operator context.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_builders</span><span class="p">:</span>
            <span class="n">identifiers</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="n">OperatorContext</span><span class="o">.</span><span class="n">active_context</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">builder</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_builders</span><span class="p">:</span>
                <span class="n">builder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifiers</span><span class="p">,</span> <span class="n">operators</span><span class="p">)</span>

        <span class="c"># We apply the keyword arguments after the rest of the tree is</span>
        <span class="c"># is created. This makes sure that parameters passed in by the</span>
        <span class="c"># user are not overridden by default expression bindings.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trait_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># If this widget is top level, then the a bottom-up traversal</span>
        <span class="c"># is performed to fire off the initialization events.</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_post_init_traverse</span><span class="p">()</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Private API</span>
    <span class="c">#--------------------------------------------------------------------------</span></div>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_user_attribute</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr_type</span><span class="p">,</span> <span class="n">is_event</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A private classmethod used by the Enaml compiler machinery.</span>

<span class="sd">        This method is used to add user attributes and events to custom</span>
<span class="sd">        derived enamldef components. If the attribute already exists on </span>
<span class="sd">        the class and is not a user defined attribute, then an exception</span>
<span class="sd">        will be raised. The only method of overriding standard trait </span>
<span class="sd">        attributes is through traditional subclassing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the attribute to add to the class.</span>

<span class="sd">        attr_type : type</span>
<span class="sd">            The type of the attribute.</span>

<span class="sd">        is_event : bool</span>
<span class="sd">            True if the attribute should be a UserEvent, False if it</span>
<span class="sd">            should be a UserAttribute.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_traits</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__base_traits__</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">base_traits</span><span class="p">:</span>
            <span class="n">ttype</span> <span class="o">=</span> <span class="n">base_traits</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">trait_type</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ttype</span><span class="p">,</span> <span class="n">_OVERRIDE_ALLOWED</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;can&#39;t add &#39;</span><span class="si">%s</span><span class="s">&#39; attribute. The &#39;</span><span class="si">%s</span><span class="s">&#39; attribute on &quot;</span>
                       <span class="s">&quot;enamldef &#39;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">&#39; already exists.&quot;</span><span class="p">)</span>
                <span class="n">items</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">items</span><span class="p">)</span>

        <span class="n">trait_attr_cls</span> <span class="o">=</span> <span class="n">UserEvent</span> <span class="k">if</span> <span class="n">is_event</span> <span class="k">else</span> <span class="n">UserAttribute</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">user_trait</span> <span class="o">=</span> <span class="n">trait_attr_cls</span><span class="p">(</span><span class="n">attr_type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; is not a valid type for the &#39;</span><span class="si">%s</span><span class="s">&#39; attribute &quot;</span>
                   <span class="s">&quot;declaration on enamldef &#39;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">&#39;&quot;</span><span class="p">)</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">(</span><span class="n">attr_type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">items</span><span class="p">)</span>

        <span class="c"># XXX HasTraits.add_class_trait will raise an exception if the</span>
        <span class="c"># the trait is already defined. There does not appear to be a</span>
        <span class="c"># way to turn this off, nor does there appear to be a way to </span>
        <span class="c"># formally remove a class trait. So, we just do what the traits</span>
        <span class="c"># metaclass does when adding traits and directly add the ctrait </span>
        <span class="c"># to the appropriate class dictionaries. The add_class_trait</span>
        <span class="c"># classmethod does some extra work to make sure that the trait</span>
        <span class="c"># is added to all subclasses, but that does not appear to be</span>
        <span class="c"># needed in this case, since this method will only be called by</span>
        <span class="c"># the compiler machinery for brand new subclasses.</span>
        <span class="n">ctrait</span> <span class="o">=</span> <span class="n">user_trait</span><span class="o">.</span><span class="n">as_ctrait</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__base_traits__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrait</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__class_traits__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrait</span>

    <span class="k">def</span> <span class="nf">_post_init_traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A method called when the top level widget if fully inited.</span>

<span class="sd">        This method performs a bottom up traversal of the tree, flips</span>
<span class="sd">        the `initialized` flag, and fires off the `inited` event.</span>

<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="c"># Ensure parenting since children may be assigned quietly</span>
            <span class="c"># on initialization, outside of Enaml&#39;s control.</span>
            <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_post_init_traverse</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inited</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_bind_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">notify_only</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A private method used by the Enaml execution engine.</span>

<span class="sd">        This method is called by the Enaml operators to bind the given</span>
<span class="sd">        expression object to the given attribute name. If the attribute</span>
<span class="sd">        does not exist, an exception is raised. A strong reference to </span>
<span class="sd">        the expression object is kept internally.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the attribute on which to bind the expression.</span>
<span class="sd">        </span>
<span class="sd">        expression : AbstractExpression</span>
<span class="sd">            A concrete implementation of AbstractExpression.</span>
<span class="sd">        </span>
<span class="sd">        notify_only : bool, optional</span>
<span class="sd">            If True, the expression is only a notifier, in which case</span>
<span class="sd">            multiple binding is allowed, otherwise the new expression</span>
<span class="sd">            overrides any old non-notify expression. Defaults to False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trait</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">curr</span><span class="o">.</span><span class="n">trait_type</span> <span class="ow">is</span> <span class="n">Disallow</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Cannot bind expression. </span><span class="si">%s</span><span class="s"> object has no attribute &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="c"># If this is the first time an expression is being bound to the</span>
        <span class="c"># given attribute, then we hook up a change handler. This ensures</span>
        <span class="c"># that we only get one notification event per bound attribute.</span>
        <span class="c"># We also create the notification entry in the dict, which is </span>
        <span class="c"># a list with at least one item. The first item will always be</span>
        <span class="c"># the left associative expression (or None) and all following</span>
        <span class="c"># items will be the notify_only expressions.</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expressions</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_trait_change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_bound_attr_changed</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">expressions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

        <span class="c"># There can be multiple notify_only expressions bound to a </span>
        <span class="c"># single attribute, so they just get appended to the end of</span>
        <span class="c"># the list. Otherwise, the left associative expression gets</span>
        <span class="c"># placed at the zero position of the list, overriding any</span>
        <span class="c"># existing expression.</span>
        <span class="k">if</span> <span class="n">notify_only</span><span class="p">:</span>
            <span class="n">expressions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_expression_changed</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">expressions</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">old</span><span class="o">.</span><span class="n">expression_changed</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
            <span class="n">expression</span><span class="o">.</span><span class="n">expression_changed</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
            <span class="n">expressions</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression</span>
            
            <span class="c"># Hookup support for default value computation. We only need</span>
            <span class="c"># to add an ExpressionTrait once, since it will reach back </span>
            <span class="c"># into the _expressions dict as needed and retrieve the most</span>
            <span class="c"># current bound expression.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">trait_type</span><span class="p">,</span> <span class="n">ExpressionTrait</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_trait</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ExpressionTrait</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_parent_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The change handler for the &#39;parent&#39; attribute. </span>

<span class="sd">        This handler ensures that the child is properly removed from </span>
<span class="sd">        the children of its old parent.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The old parent will be undefined if it was garbage collected.</span>
        <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undefined</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">old</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">old</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_children_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The change handler for the &#39;children&#39; attribute.</span>

<span class="sd">        This handler will be called when the list changes as a whole. </span>
<span class="sd">        Children in the old list which are not in the new list, with</span>
<span class="sd">        &#39;self&#39; as their parent will be de-parented. Children in the </span>
<span class="sd">        new list with an improper parent will be properly parented.</span>
<span class="sd">        The &#39;children_changed&#39; event will be fired when the parenting</span>
<span class="sd">        operations are complete.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">added</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">push_added</span> <span class="o">=</span> <span class="n">added</span><span class="o">.</span><span class="n">append</span>
        <span class="n">push_removed</span> <span class="o">=</span> <span class="n">removed</span><span class="o">.</span><span class="n">append</span>
        <span class="n">old_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">old</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_set</span><span class="p">:</span>
                <span class="n">push_removed</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">old_set</span><span class="p">:</span>
                <span class="n">push_added</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">child</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children_changed</span><span class="p">({</span><span class="s">&#39;added&#39;</span><span class="p">:</span> <span class="n">added</span><span class="p">,</span> <span class="s">&#39;removed&#39;</span><span class="p">:</span> <span class="n">removed</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_children_items_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items_evt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The change handler for the &#39;children&#39; attribute.</span>

<span class="sd">        This handler will be called when the items in the list change. </span>
<span class="sd">        Children that were added will be properly parented. Children </span>
<span class="sd">        that were removed will be unparented. The &#39;children_changed&#39; </span>
<span class="sd">        event will be fired when the parenting operations are complete.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">added</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">push_added</span> <span class="o">=</span> <span class="n">added</span><span class="o">.</span><span class="n">append</span>
        <span class="n">push_removed</span> <span class="o">=</span> <span class="n">removed</span><span class="o">.</span><span class="n">append</span>
        <span class="c"># XXX Traits workaround: Traits does not handle list slice </span>
        <span class="c"># assignment with a step properly. When that happens the </span>
        <span class="c"># event lists will contain a nested list with the change. </span>
        <span class="n">removed_items</span> <span class="o">=</span> <span class="n">items_evt</span><span class="o">.</span><span class="n">removed</span>
        <span class="n">added_items</span> <span class="o">=</span> <span class="n">items_evt</span><span class="o">.</span><span class="n">added</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed_items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">removed_items</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">removed_items</span> <span class="o">=</span> <span class="n">removed_items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">added_items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">added_items</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">added_items</span> <span class="o">=</span> <span class="n">added_items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">old_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">removed_items</span><span class="p">)</span>
        <span class="n">new_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">added_items</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">removed_items</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_set</span><span class="p">:</span>
                <span class="n">push_removed</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">added_items</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">old_set</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> 
                <span class="n">push_added</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">child</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c"># The items event makes no guarantees about ordering. Most</span>
        <span class="c"># consumers of this event, however, will care about it.</span>
        <span class="n">added</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children_changed</span><span class="p">({</span><span class="s">&#39;added&#39;</span><span class="p">:</span> <span class="n">added</span><span class="p">,</span> <span class="s">&#39;removed&#39;</span><span class="p">:</span> <span class="n">removed</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_get_base_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The property getter for the &#39;base_names&#39; attribute.</span>

<span class="sd">        This property getter returns the list of names for all base</span>
<span class="sd">        classes in the instance type&#39;s mro, starting with its current</span>
<span class="sd">        type and stopping with Declarative.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span>
            <span class="n">base_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="n">Declarative</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">base_names</span>
        
    <span class="k">def</span> <span class="nf">_on_expression_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A private signal callback for the expression_changed signal</span>
<span class="sd">        of the bound expressions. It updates the value of the attribute</span>
<span class="sd">        with the new value from the expression.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_on_bound_attr_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A private handler which is called when any attribute which</span>
<span class="sd">        has a bound signal changes. It calls the notify method on each</span>
<span class="sd">        of the expressions bound to that attribute, but if the component</span>
<span class="sd">        is marked as live.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The check for None is for the case where there are no left </span>
        <span class="c"># associative expressions bound to the attribute, so the first</span>
        <span class="c"># entry in the list is still None.</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expressions</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Public API</span>
    <span class="c">#--------------------------------------------------------------------------</span>
<div class="viewcode-block" id="Declarative.snapshot"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a snapshot of the tree starting from this component.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">            A dictionary snapshot of the declarative component tree, </span>
<span class="sd">            from this component downward.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">snap</span><span class="p">[</span><span class="s">&#39;class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_name</span>
        <span class="n">snap</span><span class="p">[</span><span class="s">&#39;bases&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_names</span>
        <span class="n">snap</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">snap</span><span class="p">[</span><span class="s">&#39;children&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">snapshot</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snap_children</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">snap</span>
</div>
<div class="viewcode-block" id="Declarative.snap_children"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.snap_children">[docs]</a>    <span class="k">def</span> <span class="nf">snap_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the children to include in the snapshot.</span>

<span class="sd">        This method is called to retrieve the children to include with</span>
<span class="sd">        the snapshot of the component. The default implementation just</span>
<span class="sd">        returns the list of `children`. Subclasses should reimplement</span>
<span class="sd">        this method if they need more control.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : iterable</span>
<span class="sd">            An iterable of children to include in the component</span>
<span class="sd">            snapshot.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
</div>
<div class="viewcode-block" id="Declarative.traverse"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.traverse">[docs]</a>    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth_first</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Yields all of the nodes in the tree, from this node downward.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        depth_first : bool, optional</span>
<span class="sd">            If True, yield the nodes in depth first order. If False,</span>
<span class="sd">            yield the nodes in breadth first order. Defaults to False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth_first</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="n">stack_pop</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span>
            <span class="n">stack_extend</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">extend</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
            <span class="n">stack_pop</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">popleft</span>
            <span class="n">stack_extend</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">extend</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">stack_pop</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">item</span>
            <span class="n">stack_extend</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Declarative.traverse_ancestors"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.traverse_ancestors">[docs]</a>    <span class="k">def</span> <span class="nf">traverse_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Yields all of the nodes in the tree, from the parent of this </span>
<span class="sd">        node updward, stopping at the given root.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root : Declarative, optional</span>
<span class="sd">            The component at which to stop the traversal. Defaults</span>
<span class="sd">            to None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">and</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">parent</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">parent</span>
</div>
<div class="viewcode-block" id="Declarative.find"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Locate and return the first named item that exists in the </span>
<span class="sd">        subtree which starts at this node.</span>

<span class="sd">        This method will traverse the tree of components, breadth first,</span>
<span class="sd">        from this point downward, looking for a component with the given</span>
<span class="sd">        name. The first one with the given name is returned, or None if</span>
<span class="sd">        no component is found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the component for which to search.</span>
<span class="sd">        </span>
<span class="sd">        regex : bool, optional</span>
<span class="sd">            Whether the given name is a regex string which should be</span>
<span class="sd">            matched against the names of children instead of tested</span>
<span class="sd">            for equality. Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Declarative or None</span>
<span class="sd">            The first component found with the given name, or None if </span>
<span class="sd">            no component is found.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regex</span><span class="p">:</span>
            <span class="n">rgx</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">rgx</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">==</span> <span class="n">name</span>
        <span class="k">for</span> <span class="n">cmpnt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">cmpnt</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cmpnt</span>
</div>
<div class="viewcode-block" id="Declarative.find_all"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.find_all">[docs]</a>    <span class="k">def</span> <span class="nf">find_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Locate and return all the named items that exist in the</span>
<span class="sd">        subtree which starts at this node.</span>

<span class="sd">        This method will traverse the tree of components, breadth first,</span>
<span class="sd">        from this point downward, looking for a components with the given</span>
<span class="sd">        name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the components for which to search.</span>
<span class="sd">        </span>
<span class="sd">        regex : bool, optional</span>
<span class="sd">            Whether the given name is a regex string which should be</span>
<span class="sd">            matched against the names of children instead of tested</span>
<span class="sd">            for equality. Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : list of Declarative</span>
<span class="sd">            The list of components found with the given name, or an</span>
<span class="sd">            empty list if no components are found.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regex</span><span class="p">:</span>
            <span class="n">rgx</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">rgx</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">==</span> <span class="n">name</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">push</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append</span>
        <span class="k">for</span> <span class="n">cmpnt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">cmpnt</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="n">push</span><span class="p">(</span><span class="n">cmpnt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    </div>
<div class="viewcode-block" id="Declarative.when"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.when">[docs]</a>    <span class="k">def</span> <span class="nf">when</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">switch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A method which returns itself or None based on the truth of</span>
<span class="sd">        the argument.</span>

<span class="sd">        This can be useful to easily turn off the effects of a component</span>
<span class="sd">        if various situations such as constraints-based layout.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        switch : bool</span>
<span class="sd">            A boolean which indicates whether the instance or None </span>
<span class="sd">            should be returned.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : self or None</span>
<span class="sd">            If &#39;switch&#39; is boolean True, self is returned. Otherwise,</span>
<span class="sd">            None is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">switch</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="c">#--------------------------------------------------------------------------</span>
    <span class="c"># Overrides</span>
    <span class="c">#--------------------------------------------------------------------------</span></div>
    <span class="n">_trait_change_notify_flag</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<div class="viewcode-block" id="Declarative.trait_set"><a class="viewcode-back" href="../../../api_ref/enaml.core.html#enaml.core.declarative.Declarative.trait_set">[docs]</a>    <span class="k">def</span> <span class="nf">trait_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trait_change_notify</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">traits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; An overridden HasTraits method which keeps track of the</span>
<span class="sd">        trait change notify flag.</span>

<span class="sd">        The default implementation of trait_set has side effects if a</span>
<span class="sd">        call to setattr(...) causes a recurse into trait_set in that</span>
<span class="sd">        the notification context of the original call will be reset.</span>

<span class="sd">        This reimplemented method will make sure that context is reset</span>
<span class="sd">        appropriately for each call. This is required for Enaml since</span>
<span class="sd">        bound attributes are lazily computed and set quitely on the</span>
<span class="sd">        fly. </span>

<span class="sd">        A ticket has been filed against traits trunk:</span>
<span class="sd">            https://github.com/enthought/traits/issues/26</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trait_change_notify_flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trait_change_notify_flag</span> <span class="o">=</span> <span class="n">trait_change_notify</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trait_change_notify</span><span class="p">(</span><span class="n">trait_change_notify</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">traits</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trait_change_notify_flag</span> <span class="o">=</span> <span class="n">last</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trait_change_notify</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../enaml-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">enaml 0.3alpha documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
  
    <li><a href="#">enaml.core.declarative</a></li>
  

      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Enthought, Inc..
      Last updated on Sep 12, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>