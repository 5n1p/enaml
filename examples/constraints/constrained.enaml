# "Realistic" demo of how the constraint-based layout engine can be used to
# create fluid, adaptable layouts.
#
# At the top, we have the "Frame" PushButton that is just a dummy standin for
# a larger, expandable widget, like a table. Below the Frame are four
# PushButtons. On the left are the Add and Remove buttons, which hug the left
# and bottom sides of their container and stay close to each other. Hugging the
# bottom right corner is the Share PushButton. Centered is the Change Mode
# PushButton. However, as the window gets resized, the Change Mode button may
# not be able to be centered, but it will always leave a gap between it and its
# two neighbors.

defn MainWindow:
    Window:
        PushButton -> frame:
            text = 'Frame'
            constraints = [
                # FIXME: these really ought to be somewhere on the Window, but
                # the .constraints attribute is used *by* the parent to lay out
                # its children, not for the component to lay out *its* children.
                L.V(L.I, L._, frame, L._, add_button, L._, L.I),
                L.H(L.I, L._, frame, L._, L.I),
                L.H(L.I, L._, add_button, L._, remove_button, L.spring(), change_mode_button, L.spring(), share_button, L._, L.I),
                height >= 100,
                width >= 200,
            ]
        PushButton -> add_button:
            text = 'Add'
            # FIXME: these size hints ought to be defaults, but we haven't made
            # a convenient syntax to override such defaults.
            constraints = [L.size_hint(self)]
        PushButton -> remove_button:
            text = 'Remove'
            constraints = [L.size_hint(self)]
        PushButton -> change_mode_button:
            text = 'Change Mode'
            constraints = [
                L.size_hint(self),
                (h_center == parent.h_center) | 'weak',
            ]
        PushButton -> share_button:
            text = 'Share...'
            constraints = [L.size_hint(self)]


