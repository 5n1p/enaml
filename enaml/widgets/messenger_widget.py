#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import defaultdict
from uuid import uuid4

from traits.api import Instance, Str

from enaml.async.async_application import AsyncApplication, AbstractBuilder
from enaml.async.async_messenger import AsyncMessenger
from enaml.core.base_component import BaseComponent


class LoopbackContext(object):
    """ A context manager generated by a LoopbackGuard which manages
    acquiring and releasing the lock items.

    """
    def __init__(self, guard, lock_items):
        """ Initialize a LoopbackContext

        Parameters
        ----------
        guard : LoopbackGuard
            The loopback guard instance for which we will acquire the
            lock for the items.

        lock_items : iterable
            An iterable items which will be passed to the 'acquire'
            method on the loopback guard.

        """
        self._guard = guard
        self._lock_items = lock_items

    def __enter__(self):
        """ Acquire the guard lock on the lock items.

        """
        self._guard.acquire(self._lock_items)

    def __exit__(self, exc_type, exc_value, traceback):
        """ Release the guard lock on the lock items.

        """
        self._guard.release(self._lock_items)


class LoopbackGuard(object):
    """ A guard object used by the MessengerWidget to protect against
    loopback conditions while updating attributes on the component.

    Instances of this class are callable and return a guarding 
    context manager for the provided lock items.

    """
    def __init__(self):
        """ Initialize a LoopbackGuard.

        """
        self._locked = defaultdict(int)

    def __call__(self, *items):
        """ Return a context manager which will guard the given items.

        Parameters
        ----------
        *items
            The items for which to acquire the guard from within the
            returned context manager. These items must be hashable.

        Returns
        -------
        result : LoopbackContext
            A context manager which will acquire the guard for the
            provided items.

        """
        return LoopbackContext(self, items)

    def __contains__(self, item):
        """ Returns whether or not the given item is currently guarded.

        Parameters
        ----------
        item : object
            The item to check for guarded state.

        Returns
        -------
        result : bool
            True if the item is currently guarded, False otherwise.

        """
        return item in self._locked

    def acquire(self, lock_items):
        """ Acquire the guard for the given lock items.

        This method is normally called by the LoopbackContext returned
        by calling this instance. User code should not normally call
        this method directly.

        It is safe to call this method multiple times for the same
        item, provided it is paired with an equivalent number of 
        calls to release(...). The guard will be released when 
        the acquired count on the item reaches zeros.

        Parameters
        ----------
        lock_items : iterable
            An iterable of objects for which to acquire the guard. The
            items must be hashable.

        """
        for item in lock_items:
            self._locked[item] += 1

    def release(self, lock_items):
        """ Release the guard for the given lock items.

        This method is normally called by the LoopbackContext returned
        by calling this instance. User code should not normally call
        this method directly.

        It is safe to call this method multiple times for the same
        item, provided it is paired with an equivalent number of 
        calls to acquire(...). The guard will be released when 
        the acquired count on the item reaches zeros.

        Parameters
        ----------
        lock_items : iterable
            An iterable of objects for which to release the guard. The
            items must be hashable.

        """
        for item in lock_items:
            self._locked[item] -= 1
            if self._locked[item] == 0:
                del self._locked[item]


class MessengerWidget(AsyncMessenger, BaseComponent):
    """ The base class of all widgets in Enaml.

    This extends BaseComponent with the ability to send and receive
    commands to and from a client widget by mixing in the AsyncMessenger
    class.

    """
    #: A loopback guard used to prevent ping ponging of messages when
    #: setting attributes from with a receive handler.
    loopback_guard = Instance(LoopbackGuard, ())    

    #: A uuid given to every messenger widget. This is not directly used
    #: by this class, but can be useful for sublasses to create mappings
    #: between objects on the client and server. It is also used by the
    #: constraints layout system to identify the owner of constraint 
    #: variables. This should never be modified by user code.
    uuid = Instance(str, factory=lambda: uuid4().hex)

    #: A string provided to implementation clients indicated which type
    #: of widget they should construct. The default type is computed
    #: based on the name of the component class. This may be overridden
    #: by users to define custom behavior, but is typically not needed.
    widget_type = Str
    def _widget_type_default(self):
        return type(self).__name__

    #: The private storage for the widget tree builder. A reference must
    #: be kept to the builder, since the lifetime of the implementation
    #: widgets is tied to the lifetime of the builder.
    _builder = Instance(AbstractBuilder)

    def build_info(self):
        """ Returns the dictionary of build info for the component tree
        from this point downward.

        XXX - this needs to be formalized a bit more.
        
        """
        info = {}
        info['uuid'] = self.uuid
        info['widget'] = self.widget_type
        info['attrs'] = self.initial_attrs()
        info['send_pipe'] = self.send_pipe
        info['recv_pipe'] = self.recv_pipe
        info['children'] = [child.build_info() for child in self.children]
        return info

    def initial_attrs(self):
        """ Returns a dictionary of attributes to initialize on the
        client widget.

        XXX - document what types of things to put in this dict.

        """
        return {}

    def initialize(self):
        """ A re-implemented initialize method which calls the bind()
        method on the widgets to allow notification handlers to be 
        hooked up.

        """
        super(MessengerWidget, self).initialize()
        self.bind()

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        The default implementation is a no-op, but is provided to be
        super()-friendly.

        """
        pass

    def default_send(self, *attrs):
        """ A convenience method provided for subclasses to use to bind
        an arbitrary number of attributes to a handler which will send
        the attribute change to the client. 

        The command generated for the client is created by mangling
        'set_' with the name of the changed attribute.

        """
        otc = self.on_trait_change
        handler = self._send_attr_handler
        for attr in attrs:
            otc(handler, attr)

    def set_guarded(self, **attrs):
        """ A convenience method provided for subclasses to set a
        sequence of attributes from within a loopback guard.

        Parameters
        ----------
        **attrs
            The attributes which should be set on the component from
            within a loopback guard context.

        """
        with self.loopback_guard(*attrs):
            for name, value in attrs.iteritems():
                setattr(self, name, value)

    def prepare(self):
        """ Prepare this widget for use before call the .run() method
        of an application.

        """
        if not self.initialized:
            self.initialize()
        builder = self._builder
        if builder is None:
            builder = self._builder = AsyncApplication.instance().builder()
            build_info = self.build_info()
            builder.build(build_info)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _send_attr_handler(self, name, new):
        """ A trait change handler which will send an attribute change
        to a client by mangling the attr name with 'set_'.

        The value of the attribute is expected to be simply serializable.
        If the loopback guard is held for the given name, the message
        will be ignored and discarded.

        """
        if name not in self.loopback_guard:
            msg = 'set_' + name
            self.send({'action':msg, name:new})

