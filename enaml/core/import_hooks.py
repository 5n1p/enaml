#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod
from collections import defaultdict
import os
import sys
import types

from .enaml_compiler import EnamlCompiler
from .parser import parse


# Backport of Py3k abstractclassmethod
class abstractclassmethod(classmethod):
    __isabstractmethod__ = True
    def __init__(self, func):
        func.__isabstractmethod__ = True
        super(abstractclassmethod, self).__init__(func)


#------------------------------------------------------------------------------
# Abstract Enaml Importer
#------------------------------------------------------------------------------
class AbstractEnamlImporter(object):
    """ An abstract base class which defines the api required to 
    implement an Enaml importer.

    """
    __metaclass__ = ABCMeta

    # Count the number of times an importer has been installed. 
    # Only uninstall it when the count hits 0 again. This permits 
    # proper nesting of import contexts.
    _install_count = defaultdict(int)

    @classmethod
    def install(cls):
        """ Appends this importer into sys.meta_path.

        """
        cls._install_count[cls] += 1
        if cls not in sys.meta_path:
            sys.meta_path.append(cls)
    
    @classmethod
    def uninstall(cls):
        """ Removes this importer from sys.meta_path.

        """
        cls._install_count[cls] -= 1
        if cls._install_count[cls] <= 0 and cls in sys.meta_path:
            sys.meta_path.remove(cls)

    @classmethod
    def parse_enaml(cls, enaml_source, filename):
        """ Returns the ast generated by the enaml parser.

        Arguments
        ---------
        enaml_source : string
            The enaml source code to parse.

        filename : string
            The filename to associate with the generated code.

        """
        return parse(enaml_source, filename=filename)

    #--------------------------------------------------------------------------
    # Python Import API
    #--------------------------------------------------------------------------
    @classmethod
    def find_module(cls, fullname, path=None):
        """ Finds the given Enaml module and returns an importer, or
        None in if the module is not found.

        """
        loader = cls.locate_module(fullname, path)
        if loader is not None:
            if not isinstance(loader, AbstractEnamlImporter):
                msg = 'Enaml imports received invalid loader object %s'
                raise ImportError(msg % loader)
            return loader

    def load_module(self, fullname):
        """ Loads and returns the Python module for the given enaml path.
        The created module is added to sys.modules.

        """
        source, path = self.get_source()
        mod = sys.modules.setdefault(fullname, types.ModuleType(fullname))
        mod.__loader__ = self
        mod.__file__ = path
        enaml_ast = self.parse_enaml(source, path)
        EnamlCompiler.compile(enaml_ast, mod.__dict__)
        return mod

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    @abstractclassmethod
    def locate_module(cls, fullname, path=None):
        """ Searches for the given Enaml module and returns an instance 
        of this class on success.

        Paramters
        ---------
        fullname : string
            The fully qualified name of the module.
        
        path : string or None
            The subpackage __path__ for submodules and subpackages
            or None if a top-level module.

        Returns
        -------
        results : Instance(AbstractEnamlImporter) or None
            If the Enaml module is located an instance of the importer
            that will perform the rest of the operations is returned. 
            Otherwise, returns None.
        
        """
        msg = ('locate_module is an abstract classmethod of the class '
               'AbstractEnamlImporter and must be implemented by '
               'subclasses.')
        raise NotImplementedError(msg)

    @abstractmethod
    def get_source(self):
        """ Reads and returns the enaml source code for the module being
        imported and the full path to the file from which it was read.

        Returns
        -------
        result : (source, filename)
            The source code of the .enaml module as a string, and
            the full path to the module as a string.

        """
        msg = ('get_source is an abstract method of the class '
               'AbstractEnamlImporter and must be implemented by '
               'subclasses.')
        raise NotImplementedError(msg)


#------------------------------------------------------------------------------
# Default Enaml Importer
#------------------------------------------------------------------------------
class EnamlImporter(AbstractEnamlImporter):
    """ The standard Enaml importer which can import Enaml modules from
    standard locations on the python path.

    """
    @classmethod
    def locate_module(cls, fullname, path=None):
        """ Searches for the given Enaml module and returns an instance 
        of this class on success.

        Paramters
        ---------
        fullname : string
            The fully qualified name of the module.
        
        path : list or None
            The subpackage __path__ for submodules and subpackages
            or None if a top-level module.

        Returns
        -------
        results : Instance(AbstractEnamlImporter) or None
            If the Enaml module is located an instance of the importer
            that will perform the rest of the operations is returned. 
            Otherwise, returns None.
        
        """
        # We're looking inside a package and 'path' the package path
        if path is not None:
            stem = fullname.rsplit('.', 1)[-1] + os.path.extsep + 'enaml'
            for root in path:
                enaml_path = os.path.join(root, stem)
                if os.path.exists(enaml_path):
                    return cls(enaml_path)
        
        # We're trying a load a package
        elif '.' in fullname:
            return
        
        # We're doing a direct import
        else:
            stem = fullname + os.path.extsep + 'enaml'
            for root in sys.path:
                enaml_path = os.path.join(root, stem)
                if os.path.exists(enaml_path):
                    return cls(enaml_path)

    def __init__(self, enaml_path):
        """ Initialize an importer object.

        Parameters
        ----------
        enaml_path : string
            The full path to the .enaml file.

        """
        self.enaml_path = enaml_path
    
    def get_source(self):
        """ Reads and returns the enaml source code for the module being
        imported and the full path to the file from which it was read.

        Returns
        -------
        result : (source, filename)
            The source code of the .enaml module as a string, and
            the full path to the module as a string.

        """
        path = self.enaml_path
        with open(path) as f:
            source = f.read()
        return (source, path)


#------------------------------------------------------------------------------
# Enaml Imports Context
#------------------------------------------------------------------------------
class imports(object):
    """ A context manager that hooks/unhooks the enaml meta path
    importer for the duration of the block. The helps user avoid
    unintended consequences of a having a meta path importer slow
    down all of their other imports.

    """
    #: The framework-wide importers in use. We always have the default
    #: importer available, unless it is explicitly removed.
    __importers = [EnamlImporter]

    @classmethod
    def get_importers(cls):
        """ Returns a tuple of currently active importers in use for the
        framework.

        """
        return tuple(cls.__importers)

    @classmethod
    def add_importer(cls, importer):
        """ Add an importer to the list of importers for use with the 
        framework. It must be a subclass of AbstractEnamlImporter.
        The most recently appended importer is used first. If the 
        importer has already been added, this is a no-op. To move
        an importer up in precedence, remove it and add it again.

        """
        if not issubclass(importer, AbstractEnamlImporter):
            msg = ('An Enaml importer must be a subclass of '
                   'AbstractEnamlImporter. Got %s instead.')
            raise TypeError(msg % importer)
        importers = cls.__importers
        if importer not in importers:
            importers.append(importer)
    
    @classmethod
    def remove_importer(cls, importer):
        """ Removes the importer from the list of active importers. 
        If the importer is not in the list, this is a no-op.

        """
        importers = cls.__importers
        if importer in importers:
            importers.remove(importer)

    def __init__(self):
        """ Initializes an Enaml import context.

        """
        self.importers = self.get_importers()

    def __enter__(self):
        """ Installs the current importer upon entering the context.

        """
        # Install the importers reversed so that the newest ones 
        # get first crack at the import on sys.meta_path.
        for importer in reversed(self.importers):
            importer.install()
    
    def __exit__(self, *args, **kwargs):
        """ Uninstalls the current importer when leaving the context.

        """
        # We removed in standard order since thats a more efficient
        # operation on sys.meta_path.
        for importer in self.importers:
            importer.uninstall()

