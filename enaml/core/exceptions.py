#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------


class DeclarativeNameError(NameError):
    """ A NameError subclass which nicely formats the exception.

    This class is intended for used by Declarative and its subclasses to
    report errors for failed global lookups when building out the object
    tree.

    """
    def __init__(self, name, filename, lineno, block):
        """ Initialize a DeclarativeNameError.

        Parameters
        ----------
        name : str
            The name of global symbol which was not found.

        filename : str
            The filename where the lookup failed.

        lineno : int
            The line number of the error.

        block : str
            The name of the lexical block in which the lookup failed.

        """
        super(DeclarativeNameError, self).__init__(name)
        self.name = name
        self.filename = filename
        self.lineno = lineno
        self.block = block

    def __str__(self):
        """ A nicely formatted representaion of the exception.

        """
        # The first two lines mimic the standard NameError.
        template = '%s\n\nFile "%s", line %d, in %s()'
        args = (self.name, self.filename, self.lineno, self.block)
        template = template % args

        # Try to open the file and read the three lines which bracket
        # the line number of the error for some contextual feedback.
        # XXX this should be augmented for code which was imported
        # from something other than the user's local filesystem.
        lineno = self.lineno
        if lineno == 0:
            first = lineno
            last = first + 2
        else:
            first = lineno - 1
            last = lineno + 1
        lines = []
        try:
            with open(self.filename, 'r') as f:
                for idx, line in enumerate(f, 1):
                    if idx >= first and idx <= last:
                        lines.append((idx, line))
                    elif idx > last:
                        break
        except IOError:
            pass

        # If the source lines were succesfully read, add in the excerpt
        # of the filed along with helpful line numbers and a pointer to
        # the offending line of code. This mimics what the final lines
        # of a traceback would be if the exception has been generated by
        # regular Python bytecode.
        extra = ''
        if len(lines) > 0:
            extra += '\n'
            for lno, line in lines:
                line = line.rstrip()
                if lno == lineno:
                    extra += '----> %d %s\n' % (lno, line)
                else:
                    extra += '      %d %s\n' % (lno, line)

        # Add the last line which mimics the final line of a NameError.
        extra += "\nNameError: global name '%s' is not defined"
        template += extra % self.name

        return template

