#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" An amalgamation of utilities used throughout the Enaml framework.

"""
from collections import defaultdict
from types import MethodType
from weakref import ref


class abstractclassmethod(classmethod):
    """ A backport of the Python 3's abc.abstractclassmethod.

    """
    __isabstractmethod__ = True

    def __init__(self, func):
        func.__isabstractmethod__ = True
        super(abstractclassmethod, self).__init__(func)


class WeakMethod(object):
    """ An object which weakly binds a method with a lifetime bound
    to the lifetime of the underlying object. 

    Instances of WeakMethodWrapper are also weakref-able with a 
    lifetime which is also bound to lifetime of the method owner.

    """
    #: An internal set which will maintain a strong reference to the
    #: the underlying weak method wrapper until the owner of the 
    #: method is destroyed.
    _instances_ = set()

    def __init__(self, method, default=None):
        """ Initialize a WeakMethodWrapper.

        Parameters
        ----------
        method : A bound method object
            The bound method which should be wrapped weakly.

        default : object, optional
            The default value to return if the underlying object for
            the method has been garbage colleced. Defaults to None.

        """
        def remove(wr, thisref=ref(self)):
            this = thisref()
            if this is not None:
                this._instances_.discard(this)
        self._im_func = method.im_func
        self._im_class = method.im_class
        self._im_self_ref = ref(method.im_self, remove)
        self._default = default
        self._instances_.add(self)

    def __call__(self, *args, **kwargs):
        """ Invoke the wrapped method by reconstructing the bound
        method from its components.

        If the underlying instance object has been destroyed, this
        method will return the default value.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the method.

        """
        im_self = self._im_self_ref()
        if im_self is None:
            return self._default
        method = MethodType(self._im_func, im_self, self._im_class)
        return method(*args, **kwargs)
        

class LoopbackContext(object):
    """ A context manager generated by a LoopbackGuard which manages
    acquiring and releasing the lock items.

    """
    def __init__(self, guard, lock_items):
        """ Initialize a LoopbackContext

        Parameters
        ----------
        guard : LoopbackGuard
            The loopback guard instance for which we will acquire the
            lock for the items.

        lock_items : iterable
            An iterable items which will be passed to the 'acquire'
            method on the loopback guard.

        """
        self._guard = guard
        self._lock_items = lock_items

    def __enter__(self):
        """ Acquire the guard lock on the lock items.

        """
        self._guard.acquire(self._lock_items)

    def __exit__(self, exc_type, exc_value, traceback):
        """ Release the guard lock on the lock items.

        """
        self._guard.release(self._lock_items)


class LoopbackGuard(object):
    """ A guard object used by the MessengerWidget to protect against
    loopback conditions while updating attributes on the component.

    Instances of this class are callable and return a guarding 
    context manager for the provided lock items.

    """
    def __init__(self):
        """ Initialize a LoopbackGuard.

        """
        self._locked = defaultdict(int)

    def __call__(self, *items):
        """ Return a context manager which will guard the given items.

        Parameters
        ----------
        *items
            The items for which to acquire the guard from within the
            returned context manager. These items must be hashable.

        Returns
        -------
        result : LoopbackContext
            A context manager which will acquire the guard for the
            provided items.

        """
        return LoopbackContext(self, items)

    def __contains__(self, item):
        """ Returns whether or not the given item is currently guarded.

        Parameters
        ----------
        item : object
            The item to check for guarded state.

        Returns
        -------
        result : bool
            True if the item is currently guarded, False otherwise.

        """
        return item in self._locked

    def acquire(self, lock_items):
        """ Acquire the guard for the given lock items.

        This method is normally called by the LoopbackContext returned
        by calling this instance. User code should not normally call
        this method directly.

        It is safe to call this method multiple times for the same
        item, provided it is paired with an equivalent number of 
        calls to release(...). The guard will be released when 
        the acquired count on the item reaches zeros.

        Parameters
        ----------
        lock_items : iterable
            An iterable of objects for which to acquire the guard. The
            items must be hashable.

        """
        for item in lock_items:
            self._locked[item] += 1

    def release(self, lock_items):
        """ Release the guard for the given lock items.

        This method is normally called by the LoopbackContext returned
        by calling this instance. User code should not normally call
        this method directly.

        It is safe to call this method multiple times for the same
        item, provided it is paired with an equivalent number of 
        calls to acquire(...). The guard will be released when 
        the acquired count on the item reaches zeros.

        Parameters
        ----------
        lock_items : iterable
            An iterable of objects for which to release the guard. The
            items must be hashable.

        """
        for item in lock_items:
            self._locked[item] -= 1
            if self._locked[item] == 0:
                del self._locked[item]

